你好！欢迎来到 **2-3** 课。

这一节课是 **SQL 能力的分水岭**。
学会了 `GROUP BY`，你只能算是个“统计员”；学会了 **窗口函数 (Window Functions)**，你才算真正的“数据分析师”。

在面试中，只要问 SQL，**90% 的概率**最后一道压轴题就是窗口函数。

---

### 1. 核心痛点：普通的 GROUP BY 哪里不行？

**场景**：你有一张学生成绩表，包含 `班级`、`姓名`、`分数`。
**任务**：找出**每个班级的第一名**（包括姓名和分数）。

* **GROUP BY 的做法**：

  ```sql
  SELECT class, MAX(score) FROM students GROUP BY class;
  ```

  * *结果*：你能得到“一班最高分是 98 分”，但**你丢掉了“谁考了 98 分”这个信息**（姓名列没法选，因为它既没被聚合也没被 Group By）。
  * *更难的*：如果要找**前 2 名**呢？`GROUP BY` 直接傻眼，因为它原本的设计就是**“把多行折叠成一行”**，根本保留不了“前两行”。
* **窗口函数的做法**：
  它不折叠行，而是给每一行数据**打上一个标签**（比如排名）。数据条数不变，但多了一列“排名信息”。

---

### 2. 概念通俗化：排名的三种姿势（面试必考）

假设 **一班** 有三个学生，分数分别是：**90, 90, 80**。
我们要给他们排名，Hive 提供了三个函数，结果大不相同：

1. **`ROW_NUMBER()` —— 铁面无私的编号**

   * **逻辑**：不管分数相不相等，强行按顺序写 1, 2, 3。
   * **结果**：1, 2, 3
   * *应用*：分页查询，或者只想随机取其中一个。
2. **`RANK()` —— 奥运会规则（跳跃排名）**

   * **逻辑**：两人并列第一，第三个人就是第三名（没有第二名了）。
   * **结果**：**1, 1, 3**
   * *应用*：竞赛排名。
3. **`DENSE_RANK()` —— 紧凑排名（不跳跃）**

   * **逻辑**：两人并列第一，第三个人顺延变成第二名。
   * **结果**：**1, 1, 2**
   * *应用*：计算奖学金发放（前三名都有奖，不管几个人）。

---

### 3. 代码实操：计算每个班级的前 2 名

这是大数据开发中最经典的 **“分组 TopN”** 模板。

#### 第一步：准备数据

在 Hive 中执行：

```sql
CREATE TABLE scores (
    name STRING,
    class STRING,
    score INT
) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';

-- 这里直接用 INSERT 模拟数据（Hive支持）
INSERT INTO scores VALUES 
('Jack', 'A', 90),
('Rose', 'A', 90),
('Tom',  'A', 80),
('Jerry','B', 100),
('Mike', 'B', 99),
('Bob',  'B', 70);
```

#### 第二步：编写 SQL（核心模板）

语法口诀：**`函数() OVER (PARTITION BY 分组列 ORDER BY 排序列)`**

* `PARTITION BY class`: 相当于“在班级内部进行比赛”。
* `ORDER BY score DESC`: 成绩高的排前面。

```sql
-- 这是一个嵌套查询。
-- 第一层（子查询）：先给每个人算好排名
-- 第二层（外层）：筛选出排名 <= 2 的人

SELECT * 
FROM (
    SELECT 
        name, 
        class, 
        score,
        -- 使用 dense_rank，因为通常我们希望并列第一都算进去
        DENSE_RANK() OVER (PARTITION BY class ORDER BY score DESC) as ranking
    FROM scores
) t
WHERE t.ranking <= 2;
```

**运行结果预期**：

* **Class A**: Jack (1), Rose (1), Tom (2) —— *注意这里会有3个人，因为有两个并列第1*
* **Class B**: Jerry (1), Mike (2)

---

### 4. 进阶技巧：时间穿梭机 LAG 和 LEAD

当你需要计算**“同比/环比”**或者**“用户流失”**时，这两个函数是神器。

* **`LAG(col, n)`**: 往回看第 n 行的数据。
* **`LEAD(col, n)`**: 往后看第 n 行的数据。

**场景**：计算销售额增长率。

```sql
SELECT 
    month,
    sales,
    -- 这一列显示的是"上个月的销售额"
    LAG(sales, 1) OVER (ORDER BY month) as last_month_sales
FROM monthly_sales;
```

* 有了 `sales` 和 `last_month_sales` 在同一行，你就可以直接相减计算增长率了！

---

### 5. 课后作业：经典的“连续登录”问题（烧脑）

这是一道**阿里、字节跳动**面试极高频出现的题目。请思考思路，不需要立刻写出完美代码。

**场景**：
有一个表 `user_login`，记录了 `user_id` 和 `login_date`（用户哪天登录了）。
数据样例：

```text
UserA, 2023-01-01
UserA, 2023-01-02
UserA, 2023-01-03
UserA, 2023-01-05  <-- 中间断了一天
UserB, ...
```

**问题**：
请找出**连续登录 3 天及以上**的所有用户。

**提示思路**：

1. 如果一个人是连续登录的，那么 `登录日期` 和 `排名的序号` 之间有什么数学关系？
   * 1号登录，排名第1 -> 差值 0
   * 2号登录，排名第2 -> 差值 0
   * 3号登录，排名第3 -> 差值 0
2. 利用这个“差值”作为分组条件。

请把你的思考逻辑回复给我，这道题攻克了，你的 SQL 水平就超越 80% 的初学者了。
